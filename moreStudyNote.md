 
**overriding**
-부모,자식 클래스가 같은 이름의 메서드를 가지고 있을 때, 부모클래스가 가지고 있는 메서드를 자식클래스에서 변경하여 실행시키는 방법.  
-결과적으로, 부모클래스가 가지고 있는 기본적인 기능을 자식클래스에서 필요에 따라 변경 가능하다.
-자식클래스에서 부모클래스의 메서드를 호출하기 위해서는 자식클래스에 super라는 것을 사용해야 한다. EX)return super.메서드();?  
-overriding을 하기 위해선 메서드의 이름, 리턴 타입, 매개변수의 타입, 순서, 개수가 같아야 한다.(메서드의 서명=시그니쳐)  
-자식의 객체를 부모의 이름을 가진 변수에 인스턴스화 해서 인스턴스의 메서드를 실행시키려면 인스턴스의 부모에 존재하는 메서드여야만 실행이 되는 듯.  

**overloading**  
-같은이름의 메서드여도 서로 다른 매개변수를 가지고 있게 정의할 수 있는 방법.  
-단, 리턴타입이 다르면 안된다. EX)(void A = void A) -> O // (void A = int A) -> X  
-매개변수의 이름도 같아야 하나?  

**컴파일**  
-window+R -> cmd -> 경로이동 -> javac 컴파일할 자바파일이름.  

**패키지 import**  
Inheritance = 패키지 이름  
Calculator2 = Inheritance패키지에 속한 클래스중 하나.  

import Inheritance.*; //패키지의 모든 클래스를 가져올 때?   
import Inheritance.Calculator2; //패키지의 가져오고 싶은 클래스만.  

**API**  
-운영체제나 프로그래밍 언어에서 제공하는 기능을 제어 할 수 있도록 만든 인터페이스.  
-프로그램에 필요한 명령목록을 정리하고 명령을 받으면 응용프로그램과 상호작용하여 명령에 요청된 값을 전달.(중간매게체 같은 역할?)  
-즉, 프로그램들의 상호작용을 도와준다.  
-자바를 제어하기 위한 자바에서 제공하는 명령어들.  
-그렇다면 System.out.println();도 api인가?    

**접근제어자**  
1.public  
-어디서든 사용 가능.  
2.private  
-오직 같은 클래스에서만 사용 가능.  
3.protected  

4.default  

**public -> protected -> default -> private 순서로 접근이 자유로운 듯 하다.  
클래스맴버의 접근자는 위의 4가지이지만, 클래스의 접근자는 public와 default 2가지 뿐이다.(default클래스를 선언 할 때에는 클래스의 앞에 default를 굳이 안 붙여도 되는듯?)  
맴버와 마찬가지로 public은 패키지가 달라도 되고 default는 같은 패키지에서만 사용 가능 한 듯.**   

**abstract(추상)** 
-abstract클래스나 메서드를 사용하기 위해선 상속이 강제된다(상속받는 클래스가 있어야 한다.)  
-abstract메서드를 선언할 때에는 메서드안에 로직이 없어야 한다.  
-맴버중에 하나라도 abstract선언을 한다면 그 맴버를 담고 있는 클래스는 추상클래스가 되야 한다.  
-추상클래스는 추상메서드가 아닌 메서드를 가질 수 있다.  

**final**  
-abstract(추상)과는 반대로 상속을 금지한다.  
Ex) static final int a = 2; 라고 선언을 하면 a는 절대 변하지 않는다.  
Ex) final void obj(){}; 라고 선언한 메서드 obj는 상속 불가능.(클래스도 마찬가지.)    

**interface**  
1.interpace를 사용하여 선언. Ex)interpace A {}  
2.implements를 사용하여 구현. Ex)class B implements A {}   
-하나의 클래스에서 여러개의 인터페이스를 구현 가능하지만, 구현한 인터페이스의 메서드를 하나라도 빼먹으면 안된다. Ex)class A implements a,b{메서드들}  
-인터페이스끼리 상속이 가능하다.  
-인터페이스의 맴버는 반드시 public여야 한다.  
-인터페이스는 오로지 추상메서드와 상수만을 가질 수 있다.  
-같은 클래스를 가지고 인스턴스화 해도 인스턴스한 변수를 가지는 데이터타입에 따라 동작방법이 다른 다형성을 가질 수 있다.  
-엄격한 약속. 소통의 에러를 방지하기 위한 것. 사용자와 개발자가 상호작용하기 위함(중간 매개체 같은 역할).  
서로다른 성격과 기능을 가진 클래스들을 implements 하여 강제적으로 동일한 동작을 시키는 것.  
-클래스의 작성과 인터페이스의 구현을 동시에 진행하여 개발 시간을 단축할 수 있다고 하나 지금으로써는 아직 무슨 뜻인지 모르겠다.  


**interface와 abstarct의 차이점**  
-interface는 구체적인 로직이나 필드를 가질 수 없고 abstarct는 구체적인 로직이나 필드를 가질 수 있다.  

**Object Class**  

-  

**Object Class 메서드들**  
1.toString  
-객체를 문자로 표현.  
2.equals  
-객체와 객체가 같은지 비교.  
3.finalize  
-객체가 소멸될 때 호출되기로 약속.  
4.clone  
-객체와 똑같은 객체를 복제해주는 기능.  

**enum(열거형)**  
-서로 연관된 **상수**들의 집합.  
-코드가 매우 단순해지며 인스턴스의 생성과 상속을 방지한다.  

**참조(Reference)**  
-new를 사용해 생성하는 데이터형들은 참조데이터형이다.   
-기본데이터를 이용해 변수를 선언하면 복제, 참조데이터(new)를 이용해 변수를 선언하면 참조.  
-Ex) 컴퓨터에서 파일을 그냥 복사하는 것은 복제, 바로가기 파일을 만드는 것은 참조.  
-복제는 같은 파일을 복사하기에 똑같은 이름과 내용을 직접 가지는 파일을 복사(메모리 2배먹음).  
-참조는 그렇지 않음(원본이나 참조파일을 바꾸면 서로 적용됨,메모리 거의 먹지 않음).  

**제네릭(Generic) = 포괄적인**  
-클래스 내부에서 사용할 데이터타입을 외부에서 지정하는 방법.  

**Collections framework**  
-배열이 가진 불편한 점을 개선.  
-가장 상위에는 Collection컨테이너 Map 컨테이너로 구성.

**Collection**  
1.List와 Set  
-Collection이라는 인터페이스에 상속 받는 인터페이스들이다.  
-List는 중복을 허용하고 Set은 허용하지 않는다.  
-List는 중복되는 값이 있어도 담고 저장하지만 Set은 하나의 고유한 값만을 저장한다. 즉,List는 입력한 모든 값을 저장하고 입력한 값중 고유한 값만을 저장하는것이 Set.  

2.Iterator(반복자?)  
-컨테이너에 담겨져 있는 값들을 하나하나 꺼내 어떠한 처리를 해줄 수 있게 해주는 인터페이스.  
-next() = 

-hasNext() = 


**Map**  

   
   
-java.utill.~~ 임포트 해줘야함.  

1.ArrayList  
-원래의 배열은 값을 지정하면 지정한 값보다 많은 배열을 담을 수 없다.  
-ArrayList는 선언시 값을 지정하지 않아도 된다. 아무리 많은 데이터를 추가해도 에러가 발생하지 않음.  
-ArrayList에는 모든 데이터 타입을 담을 수 있지만 그 데이터형은 모든 데이터형의 조상인 object형이다.  
-즉, 일반데이터형에 ArrayList의 데이터를 담고 싶으면 명시적으로 형변환을 해주던지 Generic을 통해 데이터형을 지정해줘야 한다.  


**import시 클래스 이름과 import시킬 패키지가 이름이 같으면 안된다.**  
