 
**overriding**
-부모,자식 클래스가 같은 이름의 메서드를 가지고 있을 때, 부모클래스가 가지고 있는 메서드를 자식클래스에서 변경하여 실행시키는 방법.  
-결과적으로, 부모클래스가 가지고 있는 기본적인 기능을 자식클래스에서 필요에 따라 변경 가능하다.
-자식클래스에서 부모클래스의 메서드를 호출하기 위해서는 자식클래스에 super라는 것을 사용해야 한다. EX)return super.메서드();?  
-overriding을 하기 위해선 메서드의 이름, 리턴 타입, 매개변수의 타입, 순서, 개수가 같아야 한다.(메서드의 서명=시그니쳐)  
-자식의 객체를 부모의 이름을 가진 변수에 인스턴스화 해서 인스턴스의 메서드를 실행시키려면 인스턴스의 부모에 존재하는 메서드여야만 실행이 되는 듯.  

**overloading**  
-같은이름의 메서드여도 서로 다른 매개변수를 가지고 있게 정의할 수 있는 방법.  
-단, 리턴타입이 다르면 안된다. EX)(void A = void A) -> O // (void A = int A) -> X  
-매개변수의 이름도 같아야 하나?  

**컴파일**  
-window+R -> cmd -> 경로이동 -> javac 컴파일할 자바파일이름.  

**패키지 import**  
Inheritance = 패키지 이름  
Calculator2 = Inheritance패키지에 속한 클래스중 하나.  

import Inheritance.*; //패키지의 모든 클래스를 가져올 때?   
import Inheritance.Calculator2; //패키지의 가져오고 싶은 클래스만.  

**API**  
-운영체제나 프로그래밍 언어에서 제공하는 기능을 제어 할 수 있도록 만든 인터페이스.  
-프로그램에 필요한 명령목록을 정리하고 명령을 받으면 응용프로그램과 상호작용하여 명령에 요청된 값을 전달.(중간매게체 같은 역할?)  
-즉, 프로그램들의 상호작용을 도와준다.  
-자바를 제어하기 위한 자바에서 제공하는 명령어들.  
-그렇다면 System.out.println();도 api인가?    

**접근제어자**  
1.public  
-어디서든 사용 가능.  
2.private  
-오직 같은 클래스에서만 사용 가능.  
3.protected  

4.default  

**public -> protected -> default -> private 순서로 접근이 자유로운 듯 하다.  
클래스맴버의 접근자는 위의 4가지이지만, 클래스의 접근자는 public와 default 2가지 뿐이다.(default클래스를 선언 할 때에는 클래스의 앞에 default를 굳이 안 붙여도 되는듯?)  
맴버와 마찬가지로 public은 패키지가 달라도 되고 default는 같은 패키지에서만 사용 가능 한 듯.**   

**abstract(추상)** 
-abstract클래스나 메서드를 사용하기 위해선 상속이 강제된다(상속받는 클래스가 있어야 한다.)  
-abstract메서드를 선언할 때에는 메서드안에 로직이 없어야 한다.  
-맴버중에 하나라도 abstract선언을 한다면 그 맴버를 담고 있는 클래스는 추상클래스가 되야 한다.  
-추상클래스는 추상메서드가 아닌 메서드를 가질 수 있다.  

**final**  
-abstract(추상)과는 반대로 상속을 금지한다.  
Ex) static final int a = 2; 라고 선언을 하면 a는 절대 변하지 않는다.  
Ex) final void obj(){}; 라고 선언한 메서드 obj는 상속 불가능.(클래스도 마찬가지.)    

**interface**  
1.interpace를 사용하여 선언. Ex)interpace A {}  
2.implements를 사용하여 구현. Ex)class B implements A {}   
-하나의 클래스에서 여러개의 인터페이스를 구현 가능하지만, 구현한 인터페이스의 메서드를 하나라도 빼먹으면 안된다. Ex)class A implements a,b{메서드들}  
-인터페이스끼리 상속이 가능하다.  
-인터페이스의 맴버는 반드시 public여야 한다.  
-인터페이스는 오로지 추상메서드와 상수만을 가질 수 있다.  
-같은 클래스를 가지고 인스턴스화 해도 인스턴스한 변수를 가지는 데이터타입에 따라 동작방법이 다른 다형성을 가질 수 있다.  
-엄격한 약속. 소통의 에러를 방지하기 위한 것. 사용자와 개발자가 상호작용하기 위함(중간 매개체 같은 역할).  
서로다른 성격과 기능을 가진 클래스들을 implements 하여 강제적으로 동일한 동작을 시키는 것.  
-클래스의 작성과 인터페이스의 구현을 동시에 진행하여 개발 시간을 단축할 수 있다고 하나 지금으로써는 아직 무슨 뜻인지 모르겠다.  


**interface와 abstarct의 차이점**  
-interface는 구체적인 로직이나 필드를 가질 수 없고 abstarct는 구체적인 로직이나 필드를 가질 수 있다.  

**Object Class**  

-  

**Object Class 메서드들**  
1.toString  
-객체를 문자로 표현.  
2.equals  
-객체와 객체가 같은지 비교.  
3.finalize  
-객체가 소멸될 때 호출되기로 약속.  
4.clone  
-객체와 똑같은 객체를 복제해주는 기능.  




